<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Step-by-Step Circumcenter</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; display: flex; flex-direction: column; align-items: center; background: #f8fafc; color: #1e293b; margin: 0; padding: 20px; }
        canvas { background: #ffffff; border: 1px solid #cbd5e1; border-radius: 12px; cursor: crosshair; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1); }
        .ui-panel { margin-top: 20px; display: grid; grid-template-columns: 1fr 1fr; gap: 15px; background: white; padding: 20px; border-radius: 12px; border: 1px solid #e2e8f0; width: 660px; }
        .control-group { display: flex; align-items: center; gap: 10px; font-size: 14px; font-weight: 500; padding: 8px; border-radius: 6px; transition: background 0.2s; }
        .control-group:hover { background: #f1f5f9; }
        .bisector-controls { border-right: 2px solid #e2e8f0; padding-right: 20px; }
        h2 { margin-bottom: 5px; color: #0f172a; }
        .hint { font-size: 0.9em; color: #64748b; margin-bottom: 15px; }
        input[type="checkbox"] { cursor: pointer; width: 18px; height: 18px; }
        .label-blue { color: #2563eb; }
        .label-red { color: #ef4444; }
    </style>
</head>
<body>

    <h2>üìê Step-by-Step Construction</h2>
    <p class="hint">Enable the bisectors one by one to see how they converge at the center point.</p>

    <canvas id="geoCanvas" width="700" height="450"></canvas>

    <div class="ui-panel">
        <div class="bisector-controls">
            <div class="control-group">
                <input type="checkbox" id="side0"> 
                <label for="side0">Bisector of <b>Side AB</b></label>
            </div>
            <div class="control-group">
                <input type="checkbox" id="side1"> 
                <label for="side1">Bisector of <b>Side BC</b></label>
            </div>
            <div class="control-group">
                <input type="checkbox" id="side2"> 
                <label for="side2">Bisector of <b>Side CA</b></label>
            </div>
        </div>

        <div>
            <div class="control-group">
                <input type="checkbox" id="showStar"> 
                <label for="showStar" class="label-red">‚≠ê Reveal Cell Tower</label>
            </div>
            <div class="control-group">
                <input type="checkbox" id="showLines"> 
                <label for="showLines" style="color:#10b981">üìè Prove Equidistance</label>
            </div>
            <div class="control-group">
                <input type="checkbox" id="showCircle"> 
                <label for="showCircle" class="label-blue">‚≠ï Show Circumcircle</label>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('geoCanvas');
        const ctx = canvas.getContext('2d');
        
        const toggles = {
            side0: document.getElementById('side0'),
            side1: document.getElementById('side1'),
            side2: document.getElementById('side2'),
            star: document.getElementById('showStar'),
            lines: document.getElementById('showLines'),
            circle: document.getElementById('showCircle')
        };

        let points = [
            { x: 250, y: 120, label: 'Town A' },
            { x: 500, y: 200, label: 'Town B' },
            { x: 300, y: 380, label: 'Town C' }
        ];
        let dragging = null;

        function getCircumcenter(p1, p2, p3) {
            const x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y, x3 = p3.x, y3 = p3.y;
            const D = 2 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2));
            const ux = ((x1 * x1 + y1 * y1) * (y2 - y3) + (x2 * x2 + y2 * y2) * (y3 - y1) + (x3 * x3 + y3 * y3) * (y1 - y2)) / D;
            const uy = ((x1 * x1 + y1 * y1) * (x3 - x2) + (x2 * x2 + y2 * y2) * (x1 - x3) + (x3 * x3 + y3 * y3) * (x2 - x1)) / D;
            return { x: ux, y: uy };
        }

        function drawMathMarks(p1, p2, center) {
            const midX = (p1.x + p2.x) / 2;
            const midY = (p1.y + p2.y) / 2;
            const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
            
            // Congruence Ticks
            const drawTick = (x, y) => {
                ctx.beginPath();
                ctx.moveTo(x - Math.sin(angle)*6, y + Math.cos(angle)*6);
                ctx.lineTo(x + Math.sin(angle)*6, y - Math.cos(angle)*6);
                ctx.strokeStyle = '#94a3b8';
                ctx.lineWidth = 2;
                ctx.stroke();
            };
            drawTick((p1.x + midX)/2, (p1.y + midY)/2);
            drawTick((p2.x + midX)/2, (p2.y + midY)/2);

            // Right Angle Symbol
            const size = 12;
            ctx.save();
            ctx.translate(midX, midY);
            ctx.rotate(angle);
            ctx.beginPath();
            ctx.rect(0, 0, -size, -size); 
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            ctx.restore();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const center = getCircumcenter(points[0], points[1], points[2]);
            const radius = Math.sqrt(Math.pow(points[0].x - center.x, 2) + Math.pow(points[0].y - center.y, 2));

            // Draw Triangle Sides
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            ctx.lineTo(points[1].x, points[1].y);
            ctx.lineTo(points[2].x, points[2].y);
            ctx.closePath();
            ctx.strokeStyle = '#1e293b';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Bisectors
            const pairs = [[0,1], [1,2], [2,0]];
            pairs.forEach((pair, index) => {
                if (toggles['side' + index].checked) {
                    const p1 = points[pair[0]];
                    const p2 = points[pair[1]];
                    const midX = (p1.x + p2.x) / 2;
                    const midY = (p1.y + p2.y) / 2;

                    ctx.beginPath();
                    const dx = center.x - midX;
                    const dy = center.y - midY;
                    ctx.moveTo(midX - dx * 2, midY - dy * 2);
                    ctx.lineTo(midX + dx * 4, midY + dy * 4);
                    ctx.strokeStyle = 'rgba(239, 68, 68, 0.4)';
                    ctx.setLineDash([8, 4]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    drawMathMarks(p1, p2, center);
                }
            });

            if (toggles.circle.checked) {
                ctx.beginPath();
                ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(37, 99, 235, 0.2)';
                ctx.lineWidth = 4;
                ctx.stroke();
            }

            if (toggles.lines.checked) {
                points.forEach(p => {
                    ctx.beginPath();
                    ctx.moveTo(center.x, center.y);
                    ctx.lineTo(p.x, p.y);
                    ctx.strokeStyle = '#10b981';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
            }

            if (toggles.star.checked) {
                ctx.font = '28px serif';
                ctx.textAlign = 'center';
                ctx.fillText('‚≠ê', center.x, center.y + 10);
            }

            points.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
                ctx.fillStyle = '#2563eb';
                ctx.fill();
                ctx.fillStyle = '#1e293b';
                ctx.font = 'bold 13px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(p.label, p.x, p.y - 15);
            });
        }

        canvas.onmousedown = e => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            points.forEach((p, i) => {
                if (Math.sqrt((x-p.x)**2 + (y-p.y)**2) < 20) dragging = i;
            });
        };
        window.onmousemove = e => {
            if (dragging !== null) {
                const rect = canvas.getBoundingClientRect();
                points[dragging].x = Math.max(20, Math.min(canvas.width - 20, e.clientX - rect.left));
                points[dragging].y = Math.max(20, Math.min(canvas.height - 20, e.clientY - rect.top));
                draw();
            }
        };
        window.onmouseup = () => dragging = null;
        Object.values(toggles).forEach(t => t.onchange = draw);
        draw();
    </script>
</body>
</html>
